////////////////////////////////////////////////////////////////////////////////
// sam2clippoisition
//
// 2011.4.2 T.Yasuda
////////////////////////////////////////////////////////////////////////////////

#include <iostream>
//#include <map>

#include "Option.h"
#include "Utility.h"
#include "FileReader.h"
#include "SAMAlignment.h"
#include "SequenceSet.h"
#include "CoverageArray.h"
#include "EvidenceFinder.h"
#include "Tool.h"

#include <limits>
#include <algorithm>
#include <cassert>

#include <cmath>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>

#ifdef BITVECTOR_LIB_BEGIN
using namespace BitVectorLib;
#endif

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
COption::Option_t g_option_spec[] = {
  //  {"show-bam-line",            "A",0,"Flag to determine whether alignment in BAM file should be shown",0},
 {"margin-parameter",         "a",1,"The parameter for determining threshold based on coverage of margin region","0"},
 {"library-threshold",        "B",1,"File that contain threshold of discordant pairs for each library",""},
 {"bin-size",                 "b",1,"Size of bin for statistical test","1"},
 //  {"show-clipping",            "C",0,"Flag to determine whether all cordinates should be shown",0},
 {"coverage-upper-bound",     "d",1,"Threshold of coverage shown","500"},
 {"output-format",            "F",1,"Output format",""},
 {"fragment-threshold",       "f",1,"The threshold of joining fragmented edges","0"},
 {"genome-size",              "G",1,"Genome size","300000000"},
 {"cluster-gap-threshold",    "g",1,"Threshold of gaps between positions in clusters","3"},
 {"coverage-threshold",       "k",1,"Threshold of read coverage to fill SV region","1"},
 {"dangling-distance",        "L",1,"Threshold of dangling distance displayed","10000"},
 {"clipping-length-threshold","l",1,"Threshold of clipping length","10"},
 {"margin-size",              "M",1,"The size of margine region for calculating outside coverage","0"},
 {"show-memory-usage",        "m",0,"Show memory usage",0},
 {"output-stderr",            "O",1,"Type of output to stderr (D(angling),V(ariation))","D"},
 {"progress-interval",        "p",1,"Interval for progress report","0"},
 //{"mininum-quality-symbol",   "q",1,"The symbol representing the minimum quality in SAM format","'!'"},
 {"refinement-threshold",     "R",1,"Highest coverage where refinement will be applied","-1"},
 {"max-read-length",          "r",1,"Maximum length of short reads","256"},
 {"cluster-size-threshold",   "s",1,"Threshold of cluster size","2"},
 {"verbose",                  "V",0,"Show extra messages",0},
 {"coverage-window",          "W",1,"Size and scale factor of coverage distribution","0:100:100"},
 {"max-chop-length",          "x",1,"Maximum allowed trimming length","200"},
 {0,0,0,0}
};

int true_main(int argc, char *argv[]){
  // Command line arguments
  int skip = Option().SetUp(argc, argv, g_option_spec);
  int n_args = argc-skip;
  std::ostream& helpout = std::cout;
  if(n_args<1){
    helpout<<"Usage: "<<argv[0]<<" [<options>] <subcommand> ..."<<std::endl;
    //helpout<<"Improve resolution:"<<std::endl;
    helpout<<std::endl;
    helpout<<"DESCRIPTIONS\n";
    helpout<<std::endl;
    helpout<<"   chopsticks trim <chromosome no.> <accession table> <sam file> <gff/bed file>"<<std::endl;
    helpout<<std::endl;
    helpout<<"      Improves resolution of deletion calls by trimming ends of deletion calls.\n";
    helpout<<std::endl;
    helpout<<"      <chromosome no.>\n";
    helpout<<"          ChopSticks focuses on the specified chromosome.\n";
    helpout<<"      <accession table>\n";
    helpout<<"          This file should contains in each line a pare of tab-delimited a chromosome\n";
    helpout<<"          numbers and sequence names.\n";
    helpout<<"          ChopSticks recognizes chromosome numbers even if reference names are\n";
    helpout<<"          not written as chromosome numbers.\n";
    helpout<<"      <sam file>\n";
    helpout<<"          Results of mapping NGS sequence to the genome sequence,\n";
    helpout<<"          generated by sequence aligners (ex. BWA).\n";
    helpout<<"      <gff/bed file>\n";
    helpout<<"          Deletion calls to be used.\n";
    helpout<<std::endl;
    helpout<<"      OUTPUT:\n";
    helpout<<"         Unless a format is specified by -F option, the following output will be written\n";
    helpout<<"         to the standard output.\n";
    helpout<<"         (1) 'V' is written as a first character of each line.\n";
    helpout<<"         (2) Identification number assigned to the deletion.\n";
    helpout<<"         (3) Average coverage in the deletion call.\n";
    helpout<<"         (4) [<Starting position of the deletion>,<Ending position of the deletion>)\n";
    helpout<<"         (5) Improved position of the deletion.\n";
    helpout<<std::endl;
    helpout<<"      EXAMPLE:\n";
    helpout<<"         chopstick -Fbed -V -f0.8 -k2 trim 1 acc2chr.txt alignment.bam deletions.bed > improved.bed\n";
    helpout<<std::endl;
    //helpout<<"Find read-pairs supporting deletion calls:"<<std::endl;
    helpout<<std::endl;
    helpout<<"   chopsticks evidence <chromosome no.> <accession table> <sam file> <gff/bed file>"<<std::endl;
    helpout<<std::endl;
    helpout<<"      Find sequences that support deletion calls given in <gff/bed file>.\n";
    helpout<<"      The command-line arguments are the same as 'trim' subcommand above.\n";
    helpout<<std::endl;
    helpout<<"      OUTPUT:\n";
    helpout<<"         (1) standard out\n";
    helpout<<"            SAM output of reads that overlap with deletion calls.\n";
    helpout<<"            If -B option is given, threshold on minimum distance for discordant pair,\n";
    helpout<<"            distance between two reads, and whether the read is discordant or not will be\n";
    helpout<<"            output with YT,YL and YD option values.\n";
    helpout<<"         (2) standard error: if -OV is given, tab-delimited values of the following.\n";
    helpout<<"           (2-1) The first 6 values in each line of BED files, separated by ','.\n";
    helpout<<"           (2-2) Read-pairs that span the deletion call.\n";
    helpout<<"                 For each read-pair, its name, its library, and whether the read is\n";
    helpout<<"                 discordant('d') or concordant('c') are reported.\n";
    helpout<<"                 Each read of the spanning reads must be within the distance\n";
    helpout<<"                 given -L option.\n";
    helpout<<std::endl;
    helpout<<"      EXAMPLE:\n";
    helpout<<"         chopstick -OV -V -L10000 -BBDcfg.txt -M20 evidence 1 acc2chr.txt alignment.bam deletions.bed > spanning.sam 2> spanning-reads.txt\n";
    helpout<<std::endl;
    COption::ShowHelp(helpout, g_option_spec);
    helpout<<std::endl;
    helpout<<std::endl;
    helpout<<"COPYRIGHT\n";
    helpout<<"      Copyright (C) 2012 Tomohiro Yasuda.\n";
    helpout<<"      License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n";
    helpout<<"      This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.\n";
    helpout<<std::endl;
    helpout<<"AUTHOR\n";
    helpout<<"      Tomohiro Yasuda\n";
    helpout<<"      The Human Genome Center, Institute of Medical Science, the University of Tokyo.\n";
    helpout<<"      t y a s u d a (at) h g c (dot) j p\n";
    helpout<<std::endl;
    return 1;
  }

  std::string subcommand(argv[skip]);
  if(subcommand=="read_sam"){
    if(n_args<2) Quit("Usage: "<<argv[0]<<" read_feature <target file>");
    std::string target_file(argv[skip+1]);
    CFileReader fr(target_file.c_str());
    fr.SetProgressInterval(Option().RequireInteger("progress-interval"),"lines");
    while(fr.GetContentLine("@")) CSAMAlignment(fr.CurrentLine()).Show(std::cout);
  }
  /*
  else if(subcommand=="read_feature"){
    if(n_args<2) Quit("Usage: "<<argv[0]<<" read_feature <target file>");
    std::string target_file(argv[skip+1]);
    CFileReader fr(target_file.c_str());
    fr.SetProgressInterval(Option().RequireInteger("progress-interval"),"lines");
    int32_t filetype = CGeneralFeature::Filetype(target_file.c_str());
    std::cerr<<"# filetype = "<<filetype<<std::endl;
    while(fr.GetContentLine()){
      CGeneralFeature feature;
      if(! feature.Parse(fr.CurrentLine(),filetype)) continue;
      feature.WriteGFF(std::cout);
      std::cout<<std::endl;
    }
  }
  */
  else if(subcommand=="trim"){
    if(n_args<5) Quit("Usage: "<<argv[0]<<" trim <chromosome no.> <accession table> <sam file> <gff file>");
    std::string chr_str(argv[skip+1]);
    CCoverageArray ca;
    CGeneralFeatureVector gfv;
    CChromosomeNormalizer cn;
    cn.Read(argv[skip+2]);
    ca.SetUp( cn.Chr(chr_str.c_str()) );
    //gfv.ReadGFF(std::atoi(chr_str.c_str()),cn,argv[skip+4]);
    gfv.ReadGFF( cn.Chr(chr_str.c_str()), cn, argv[skip+4]);
    ca.ReadSAM(argv[skip+3],cn);
    if(Option().Find("verbose")){
      std::cerr<<"# Unknown references: ";
      cn.ShowUnknown(std::cerr);
    }
    ca.RefineRegion(std::cout,CCoverageArray::REFINE_FRAGMENTED_EDGE,gfv);
  }
  else if(subcommand=="evidence"){
    if(n_args<5) Quit("Usage: "<<argv[0]<<" evidence <chromosome no.> <accession table> <sam file> <gff file>");
    std::string chr_str(argv[skip+1]);
    CEvidenceFinder ef;
    CGeneralFeatureVector gfv;
    CChromosomeNormalizer cn;
    cn.Read(argv[skip+2]);
    gfv.ReadGFF( cn.Chr(chr_str.c_str()), cn, argv[skip+4]);
    gfv.Sort();
    ef.SetUp( cn.Chr(chr_str.c_str()) );
    ef.MakeBin( gfv );
    ef.ReadSAM(argv[skip+3],cn);
    if(Option().Find("verbose")){
      std::cerr<<"Unknown references: ";
      cn.ShowUnknown(std::cerr);
    }
  }
  /*
  else if(subcommand=="sequence_set"){
    std::string target_file(argv[skip+1]);
    if(n_args<2) Quit("Usage: "<<argv[0]<<" sequence_set <FASTQ file>");
    CFileReader fr(target_file.c_str());
    CSequenceSet sset;
    sset.Read(fr);
    sset.ShowStat(std::cout);
  }
  else if(subcommand=="options"){
    Option().Show(std::cout);
  }
  else if(subcommand=="test"){
    CSlotManager::Test(std::cout);
  }
  */
  else{
    std::cerr<<"# Unexpected subcommand: "<<subcommand<<std::endl;
  }

  if(Option().Find("show-memory-usage")){
    CProcessMemory pm;
    std::cerr<<"PeakMemory="<<pm.Peak<<std::endl;
  }
  return 0;
}

int main(int argc, char *argv[]){
  try{
    return true_main(argc,argv);
  }
  catch(CError &e){
    std::cerr<<e<<std::endl;
  }
}
